{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>Myloasm is a de novo metagenome assembler for long-read sequencing data. It takes sequencing reads and outputs polished contigs in a single command. </p> <p>Myloasm works with modern long reads such as:</p> <ul> <li>Nanopore R10 simplex reads with &gt; ~97% accuracy (basecalled in sup or hac mode)</li> <li>PacBio HiFi reads</li> </ul> <p>Installation and Usage: See the Install and Usage sections on the navigation side bar. Source code is available at the GitHub repo.</p> <p>Important</p> <p>Version 0.4.0 was released January 27, 2026. See CHANGELOG for more information.</p>"},{"location":"#why-myloasm","title":"Why myloasm?","text":"<p>Results: Here are some preliminary results for myloasm; see the preprint for more details. </p> <p>Philosophy: Myloasm was designed to take advantage of modern long reads. Even the noisiest modern long reads (e.g., nanopore simplex R10) have become quite accurate. Myloasm uses a new algorithmic framework that enables high-resolution assembly from this data.</p> <p>Strengths: </p> <ul> <li>leverages modern long-reads (e.g. nanopore R10.4) to get longer, better contigs than other assemblers</li> <li>assembles similar (intraspecies) strains better than other nanopore assemblers<ul> <li>other nanopore assemblers collapse similar genomes at &gt; 95% ANI\u2014myloasm can resolve up to 99% ANI quite confidently.</li> </ul> </li> <li>works well in diverse metagenomes, from human gut to soil</li> <li>uses about the same RAM as metaFlye with faster runtime</li> </ul> <p>Limitations: myloasm may</p> <ul> <li>occasionally produce chimeric misassembled contigs (like all metagenome assemblers)<ul> <li>we provide tools for quality control and visualization; also see the quality control guide.</li> </ul> </li> <li>use more RAM than sparse minimizer approaches like metaMDBG.</li> </ul>"},{"location":"#issues-questions-and-discussions","title":"Issues, questions, and discussions","text":"<ul> <li>Found a bug or have an issue? Go to https://github.com/bluenote-1577/myloasm/issues </li> <li>Have a general question or discussion topic? Go to https://github.com/bluenote-1577/myloasm/discussions</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>Jim Shaw, Maximillian Marin, and Heng Li. High-resolution metagenome assembly for modern long reads with myloasm. bioRxiv (2025).</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#v040-1-28-2026-at-least-30-peak-ram-than-before-at-baseline-but-possibly-up-to-80-reduced-ie-even-5-fold-for-large-metagenomes","title":"v0.4.0 (1-28-2026) - At least 30% peak RAM than before at baseline, but possibly up to ~80% reduced (i.e., even 5-fold) for large metagenomes","text":"<p>Major changes</p> <ul> <li>Data structure changes (liberal usage of variable-length quantity encodings) reduced memory by ~30-40% at baseline.</li> <li>Reworking of read mapping logic: temporary mappings do not have to be stored in memory temporarily. For large metagenomes, this could reduce peak RAM by multiple folds. </li> </ul> <p>Minor changes</p> <ul> <li>Reworked the logic for removing contained reads slightly; it now proceeds in batches. This gave slightly better results on preliminary data. </li> </ul> <p>BREAKING:</p> <ul> <li>The checkpoints from previous runs for v0.3.0 and below will no longer work. That is, if you want to resume a disrupted v0.3.0 run using <code>myloasm exist ...</code>,  you will have to use v0.3.0. </li> </ul>"},{"location":"CHANGELOG/#v030-12-19-2025-better-polishing-for-multi-strain-communities-runtime-on-complex-metagenomes","title":"v0.3.0 (12-19-2025) - Better polishing for multi-strain communities &amp; runtime on complex metagenomes","text":"<p>Major changes</p> <ul> <li>Polishing may be much improved when multiple co-existing strains are assembled for nanopore data. Otherwise, results should not change much.</li> <li>Bloom filter size is now automatically chosen by default (but can be overridden)</li> <li>Significantly improved runtime on complex metagenomes (graph cleaning + read mapping steps)</li> <li>Procedure for dereplicating spurious contigs prior to polishing changed slightly; should improve memory and time for complex metagenomes</li> </ul> <p>Minor changes:</p> <ul> <li>Added a new filter that removes poorly assembled, low-coverage contigs with mapping issues.</li> <li>Added more options for dereplication of alternate contigs</li> </ul>"},{"location":"CHANGELOG/#v020-more-conservative-and-cleaner-contig-outputs-with-better-polishing","title":"v0.2.0 - More conservative and cleaner contig outputs with better polishing","text":"<ul> <li>allow fasta reads (https://github.com/bluenote-1577/myloasm/issues/3)</li> <li>allow reads with non ACGT; send non-ACGT --&gt; A character (https://github.com/bluenote-1577/myloasm/issues/4)</li> <li>fixed some bugs with polishing. Should be more robust and have less ~200 bp gaps.</li> <li>remove ALL contigs with cov &lt;= 1 (cli parameter now)</li> <li>remove singleton contigs with cov &lt;= 3  (cli parameter now)</li> <li>fixed specific polishing issues for small circular genomes</li> <li>more aggressive dereplication of multiplied plasmids.</li> <li>changed contig output format to output <code>duplicated-yes|no|possibly</code>. k-mer multiplicity is now in an extra field due to decimal being unruly especially during contig processing.</li> </ul>"},{"location":"FAQ/","title":"Frequently asked questions","text":""},{"location":"FAQ/#question-not-answered-below","title":"Question not answered below?","text":"<p>Open up an issue or a discussion.</p>"},{"location":"FAQ/#is-there-a-way-to-resume-an-incompleted-myloasm-run","title":"Is there a way to resume an incompleted myloasm run?","text":"<p>Yes. The <code>binary_temp</code> files in the results directory contain intermediate checkpoint files. You can rerun from these checkpoints using the <code>exist</code> keyword. </p> <pre><code>myloasm exist -o results_directory (options)`\n</code></pre>"},{"location":"FAQ/#what-read-level-quality-control-does-myloasm-do-do-you-need-to-do-qc","title":"What read-level quality control does myloasm do? Do you need to do QC?","text":"<p>Myloasm removes reads with &lt; 1kbp and &lt; X% mean base quality; X is taken from <code>--quality-value-cutoff</code> (default = 90) using the fastq. Adapters are not removed from the reads. </p> <p>Adding more stringent filters is fine (e.g., filtering &gt; 99% base quality). This could improve the assembly at the cost of losing lower coverage stuff / lower contiguity.</p>"},{"location":"FAQ/#what-are-the-polishing-warnings-in-the-output-log","title":"What are the polishing warnings in the output log?","text":"<p>See the answer here. Basically, polishing is often far from perfect in real metagenomes. Myloasm detects when there are some issues and spits it out into the log. We don't do much with these warnings as of v0.3.0 (this may change). </p>"},{"location":"FAQ/#why-are-there-super-long-contigs-10-mbp-in-my-output-file","title":"Why are there super long contigs &gt; 10 Mbp in my output file?","text":"<p>These are probably chimeras (erroneously joined contigs). See mylotools for tools to inspect contigs to see if these have good coverage/read overlaps. But these could in theory be eukaryotic genomes too.</p>"},{"location":"FAQ/#does-myloasm-work-on-isolate-bacteria-plasmids-human-non-metagenomes","title":"Does myloasm work on isolate bacteria + plasmids / human / non-metagenomes?","text":"<ul> <li> <p>Isolate bacteria and plasmids: Ryan Wick benchmarked myloasm and it works pretty well on isolate bacteria ONT metagenomes. Make sure to use the newest versions. </p> </li> <li> <p>Human and complex eukaryotic genomes: Probably not. Myloasm can't handle very complex, low-entropy sequences as well as other long-read assemblers. </p> </li> <li> <p>Simpler eukaryotes: Eukaryotes with simpler genomes should be roughly okay. Telomeric sequences and long homopolymers are generally difficult for ONT reads though; see here.</p> </li> </ul>"},{"location":"FAQ/#does-myloasm-work-with-fasta-reads","title":"Does myloasm work with fasta reads?","text":"<p>Yes. Myloasm does use quality scores for a few tasks (e.g., polishing, SNPmer calling), so the results may be slightly worse. But fasta is usable. </p>"},{"location":"FAQ/#what-about-duplicated-read-ids","title":"What about duplicated read IDs?","text":"<p>Duplicated read IDs are fine. </p>"},{"location":"cmd/","title":"Command-Line Help for <code>myloasm</code>","text":"<p>This document contains the help content for the <code>myloasm</code> command-line program.</p> <p>Command Overview:</p> <ul> <li><code>myloasm</code>\u21b4</li> </ul>"},{"location":"cmd/#myloasm","title":"<code>myloasm</code>","text":"<p>myloasm - high-resolution metagenomic assembly with noisy long reads. See online documentation for full options.</p> <p>EXAMPLE (Nanopore R10): myloasm nanopore_reads.fq.gz -o output_directory -t 50 EXAMPLE (PacBio HiFi): myloasm pacbio_reads.fq.gz -o output_directory -t 50 --hifi</p> <p>Usage: <code>myloasm [OPTIONS] &lt;FASTQ/FASTA (.gz)&gt;...</code></p>"},{"location":"cmd/#arguments","title":"Arguments:","text":"<ul> <li><code>&lt;FASTQ/FASTA (.gz)&gt;</code> \u2014 Input read file(s) -- multiple files are concatenated</li> </ul>"},{"location":"cmd/#basic-algorithmic-parameters","title":"Basic Algorithmic Parameters:","text":"<ul> <li> <p><code>-c</code>, <code>--c &lt;C&gt;</code> \u2014 Compression ratio (1/c k-mers selected). Must be &lt;= 15  [<code>11</code>]</p> </li> <li> <p><code>--quality-value-cutoff &lt;QUALITY_VALUE_CUTOFF&gt;</code> \u2014 Disallow reads with &lt; % identity for graph building (estimated from base qualities)  [<code>90</code>]</p> </li> <li> <p><code>--min-ol &lt;MIN_OL&gt;</code> \u2014 Minimum overlap length for graph construction  [<code>500</code>]</p> </li> <li> <p><code>-b</code>, <code>--bloom-filter-size &lt;BLOOM_FILTER_SIZE&gt;</code> \u2014 Bloom filter size in GB. Increase for massive datasets if initial k-mer counting is a bottleneck (default: automatic estimation)</p> </li> <li><code>--aggressive-bloom</code> \u2014 More aggressive filtering of low-abundance k-mers. May be non-deterministic</li> <li><code>--new-polish-trimming</code> \u2014 New mode: trim windows during polishing. Takes slightly longer, may incrementally improve polishing for some datasets</li> <li><code>-k</code>, <code>--kmer-size &lt;KMER_SIZE&gt;</code> \u2014 K-mer size (must be odd and &lt; 24)  [<code>21</code>]</li> </ul>"},{"location":"cmd/#graph-parameters-advanced","title":"Graph Parameters (advanced):","text":"<ul> <li> <p><code>--small-bubble-threshold &lt;SMALL_BUBBLE_THRESHOLD&gt;</code> \u2014 Base bubble popping length threshold; this gets multiplied by 5-30x during progressive graph cleaning  [<code>50000</code>]</p> </li> <li> <p><code>--z-edge-threshold &lt;Z_EDGE_THRESHOLD&gt;</code> \u2014 Cut z-edges that are &lt; this times smaller than the adjacent overlaps  [<code>1</code>]</p> </li> <li> <p><code>--tip-length-cutoff &lt;TIP_LENGTH_CUTOFF&gt;</code> \u2014 Base length of tip to remove; this gets multiplied by 5-30x during simplification  [<code>20000</code>]</p> </li> <li> <p><code>--tip-read-cutoff &lt;TIP_READ_CUTOFF&gt;</code> \u2014 Number of reads in tips to remove; this gets multiplied by 5-30x during simplification  [<code>3</code>]</p> </li> <li> <p><code>--max-bubble-threshold &lt;MAX_BUBBLE_THRESHOLD&gt;</code> \u2014 Maximum bubble length to pop; keep alternates  [<code>500000</code>]</p> </li> </ul>"},{"location":"cmd/#miscellaneous-options","title":"Miscellaneous Options:","text":"<ul> <li> <p><code>--no-polish</code> \u2014 No polishing (not recommended)  [<code>false</code>]</p> </li> <li> <p><code>--no-snpmers</code> \u2014 Disable usage of SNPmers (not recommended)  [<code>false</code>]</p> </li> </ul>"},{"location":"cmd/#options","title":"Options:","text":"<ul> <li> <p><code>-o</code>, <code>--output-dir &lt;OUTPUT_DIR&gt;</code> \u2014 Output directory for results; created if it does not exist  [<code>myloasm-out</code>]</p> </li> <li> <p><code>-t</code>, <code>--threads &lt;THREADS&gt;</code> \u2014 Number of threads to use for processing  [<code>20</code>]</p> </li> <li> <p><code>--clean-dir</code> \u2014 Do not dump large intermediate data to disk (intermediate data is useful for rerunning)</p> </li> <li><code>-l</code>, <code>--log-level &lt;LOG_LEVEL&gt;</code> \u2014 Verbosity level. Warning: trace is very verbose  [<code>debug</code>]</li> </ul> <p>Possible values: <code>error</code>, <code>warn</code>, <code>info</code>, <code>debug</code>, <code>trace</code></p> <ul> <li><code>--markdown-help</code> \u2014 Print this markdown document</li> </ul>"},{"location":"cmd/#output-thresholds","title":"Output thresholds:","text":"<ul> <li> <p><code>--min-reads-contig &lt;MIN_READS_CONTIG&gt;</code> \u2014 Output contigs with &gt;= this number of reads  [<code>1</code>]</p> </li> <li> <p><code>--singleton-coverage-threshold &lt;SINGLETON_COVERAGE_THRESHOLD&gt;</code> \u2014 Remove singleton contigs with &lt;= this estimated coverage depth (DP1 coverage; 99% identity coverage)  [<code>3</code>]</p> </li> <li> <p><code>--secondary-coverage-threshold &lt;SECONDARY_COVERAGE_THRESHOLD&gt;</code> \u2014 Remove contigs with &lt;= this estimated coverage depth and &lt;= 2 reads (DP1 coverage; 99% identity coverage)  [<code>1</code>]</p> </li> <li> <p><code>--absolute-coverage-threshold &lt;ABSOLUTE_COVERAGE_THRESHOLD&gt;</code> \u2014 Remove all contigs with &lt;= this estimated coverage depth (DP1 coverage; 99% identity coverage)</p> </li> <li> <p><code>--dereplication-ani &lt;DEREPLICATION_ANI&gt;</code> \u2014 Mark contigs with &gt;= this average nucleotide identity (ANI) to a larger contig as alternate  [<code>99</code>]</p> </li> <li> <p><code>--dereplication-length &lt;DEREPLICATION_LENGTH&gt;</code> \u2014 Mark contigs with &gt; 90% aligned, &lt; this length, and &gt;= --dereplication-ani as alternate  [<code>500000</code>]</p> </li> </ul>"},{"location":"cmd/#overlap-parameters-advanced","title":"Overlap Parameters (advanced):","text":"<ul> <li> <p><code>--read-map-batch-size &lt;READ_MAP_BATCH_SIZE&gt;</code> \u2014 Batch size of indexing for read-to-read mapping and overlap stage  [<code>1000000</code>]</p> </li> <li> <p><code>--snpmer-threshold-strict &lt;SNPMER_THRESHOLD_STRICT&gt;</code> \u2014 Snpmer identity threshold for containment and strict overlaps  [<code>100</code>]</p> </li> <li> <p><code>--snpmer-threshold-lax &lt;SNPMER_THRESHOLD_LAX&gt;</code> \u2014 Snpmer identity threshold for relaxed overlaps  [<code>99</code>]</p> </li> <li> <p><code>--snpmer-error-rate-lax &lt;SNPMER_ERROR_RATE_LAX&gt;</code> \u2014 Binomial test error parameter for relaxed overlaps  [<code>0.025</code>]</p> </li> <li> <p><code>--snpmer-error-rate-strict &lt;SNPMER_ERROR_RATE_STRICT&gt;</code> \u2014 Binomial test error parameter strict overlaps  [<code>0</code>]</p> </li> <li> <p><code>--contain-subsample-rate &lt;CONTAIN_SUBSAMPLE_RATE&gt;</code> \u2014 Relaxed compression ratio during containment; must be &gt; c  [<code>44</code>]</p> </li> <li> <p><code>--absolute-minimizer-cut-ratio &lt;ABSOLUTE_MINIMIZER_CUT_RATIO&gt;</code> \u2014 Cut overlaps with &gt; (c * this) number of bases between minimizers on average  [<code>8</code>]</p> </li> <li> <p><code>--relative-minimizer-cut-ratio &lt;RELATIVE_MINIMIZER_CUT_RATIO&gt;</code> \u2014 Cut overlaps with &gt; (this) times more bases between minimizers than the best overlap on average  [<code>5</code>]</p> </li> <li> <p><code>--disable-error-overlap-rescue</code> \u2014 Disables a SNPmer error overlap rescue heuristic during graph construction</p> </li> <li><code>--maximal-end-fuzz &lt;MAXIMAL_END_FUZZ&gt;</code> \u2014 Soft clips with &lt; this # of bases are allowed for alignment  [<code>300</code>]</li> </ul>"},{"location":"cmd/#technology-presets","title":"Technology Presets:","text":"<ul> <li><code>--nano-r10</code> \u2014 (DEFAULT) R10 nanopore mode for sup/hac data (&gt; ~97% median accuracy). Specifying this flag does not do anything for now</li> <li><code>--nano-r9</code> \u2014 R9 (old nanopore) mode for low (~90%) accuracy reads. Experimental</li> <li><code>--hifi</code> \u2014 PacBio HiFi mode -- assumes less chimericism and higher accuracy</li> </ul> <p>     This document was generated automatically by     <code>clap-markdown</code>. </p>"},{"location":"install/","title":"Install","text":"<p>Myloasm can be installed in three ways. </p> <ol> <li>Bioconda</li> <li>Executable binary</li> <li>Building from source (mandatory if on ARM architectures)</li> </ol>"},{"location":"install/#conda-install-x86-64-avx2-instructions","title":"Conda install (x86-64 + AVX2 instructions)","text":"<pre><code>mamba install -c bioconda myloasm mylotools\n</code></pre> <p>This installs both (1) myloasm and (2) mylotools, a set of utilities for visualizing and manipulating myloasm's outputs. The other methods below do not install mylotools. </p>"},{"location":"install/#portable-x86-64-avx2-binary","title":"Portable x86-64 + AVX2 binary","text":"<pre><code>wget https://github.com/bluenote-1577/myloasm/releases/download/v0.4.0/myloasm-0.4.0-x86_64-avx2\nchmod +x myloasm-0.4.0-x86_64-avx2\n./myloasm-0.4.0-x86_64-avx2\n</code></pre> <ul> <li>This binary is not static but dynamically linked to older version of shared libraries (GLIBC and GLIBCXX) built on CentOS 7.</li> <li>Requires AVX2 instructions and x86-64 architectures (most linux machines). </li> </ul>"},{"location":"install/#build-from-source","title":"Build from source","text":"<p>Requirements:</p> <ul> <li>Rust programming language &gt;= v1.85</li> <li>gcc 4.8+ or clang 3.4+</li> <li>cmake 3.5+</li> </ul>"},{"location":"install/#x86-64-linux-systems-with-avx2-most-modern-machines","title":"x86-64 linux systems with AVX2 (most modern machines)","text":"<p>Compiling from source should take a few minutes.</p> <pre><code>git clone https://github.com/bluenote-1577/myloasm --recurse-submodules  \ncd myloasm\ncargo install --path . \nmyloasm -h\n</code></pre>"},{"location":"install/#sse2-but-no-avx2-instructions","title":"SSE2 but no AVX2 instructions","text":"<pre><code>cargo install --path . --features=sse --no-default-features\n</code></pre>"},{"location":"install/#arm-neon-instructions","title":"ARM NEON instructions","text":"<pre><code>cargo install --path . --features=neon --no-default-features\n</code></pre>"},{"location":"mylotools/","title":"Mylotools overview","text":"<p>Mylotools is a set of utilities for working with myloasm assemblies. Source code for mylotools can be found here.</p> <p>The main use of mylotools is to visualize assembled contigs for quality control. There are also functions for processing myloasm's contigs.  </p> A QC plot from `mylotools report` or `mylotools plot` <p>Mylotools currently has the following useful functionality:</p> <pre><code>usage: mylotools [-h] [--version] {report,sanitize-headers,plot,strain-viz,extract-contigs} ...\n\npositional arguments:\n  {report,sanitize-headers,plot,strain-viz,extract-contigs}\n    report              Generate comprehensive report with plots for all long contigs\n    sanitize-headers    Sanitize FASTA headers by replacing underscores with spaces (creates backup)\n    plot                Generate a plot of various statistics for one of myloasm's output contigs (`report` does `plot` for all contigs)\n    strain-viz          Visualize overlaps between and within two or more similar contigs\n    extract-contigs     Extract contigs &gt; X bp into a folder as its own fasta\n</code></pre>"},{"location":"mylotools/#installing-mylotools","title":"Installing mylotools","text":""},{"location":"mylotools/#conda-install","title":"Conda install","text":"<pre><code>mamba install -c bioconda mylotools\n</code></pre>"},{"location":"mylotools/#clone-pip","title":"Clone + pip","text":"<pre><code>git clone https://github.com/bluenote-1577/mylotools\ncd mylotools\n\n## assuming you have python3 installed\npip install . \n</code></pre>"},{"location":"mylotools/#using-mylotools","title":"Using mylotools","text":"<p>It's easiest to use mylotools by <code>cd</code>-ing into the assembly output. </p> <pre><code>myloasm reads.fq .... -o myloasm_results\ncd myloasm_results\n</code></pre>"},{"location":"mylotools/#generating-an-html-report","title":"Generating an HTML report","text":"<pre><code>mylotools report -o mylo-report\nls mylo-report/contig_summary_report.html\n</code></pre> <p>This extracts all contigs of length &gt; 300 kbp OR designated circular (by default) and then runs <code>mylotools plot</code> to generate QC plots. <code>contig_summary_report.html</code> is an interactive plot -- clicking a contig redirects to its QC plot. </p> A comprehensive HTML report. Clicking on the contig leads to a QC plot."},{"location":"output/","title":"Output directory","text":"<pre><code>myloasm_output \n    \u251c\u2500\u2500 assembly_primary.fa &lt;-- CONTIGS\n    \u251c\u2500\u2500 final_contig_graph.(gfa/edges) &lt;-- GRAPH \n    \u2514\u2500\u2500 OTHER STUFF (secondary files)\n</code></pre> <ul> <li>The main contig file: assembly_primary.fa<ul> <li>Contig fasta record label definition<ul> <li>Circularity</li> <li>Estimated depth of coverage </li> <li>K-mer multiplicity</li> </ul> </li> </ul> </li> <li>The final assembly graph: final_contig_graph.gfa<ul> <li>Understanding myloasm's GFA assembly graph format <ul> <li>Contig information </li> <li>Read information </li> </ul> </li> </ul> </li> </ul>"},{"location":"output/#the-main-contig-file-assembly_primaryfa","title":"The main contig file: assembly_primary.fa","text":"<p>These are the main polished contigs to be used for downstream analysis most of the time. </p>"},{"location":"output/#contig-fasta-record-label-definition","title":"Contig fasta record label definition","text":"<p>The fasta records looks like this:</p> <p>&gt;u2658272ctg_len-2275750_circular-possibly_depth-10-9-9_duplicated-no mult=1.00</p> <p><code>u2658272ctg</code> is the identifier and <code>len-X</code> is the length in nucleotides. There is also information about the circularity, depth of coverage, and repetitiveness of the contig. </p>"},{"location":"output/#circularity","title":"Circularity","text":"<p><code>circular-X</code>: X is either <code>yes</code>, <code>no</code>, or <code>possibly</code>. </p> <p>If a contig has a self loop in the assembly graph and </p> <ol> <li>has average depth &gt; 5x and </li> <li>has no other connections (i.e., consists of a single node and a single edge) </li> </ol> <p>then it is <code>yes</code>. </p> <p>If it has a self loop, but (1) or (2) fails above, then it is <code>possibly</code>. Otherwise, it is <code>no</code>. </p>"},{"location":"output/#estimated-depth-of-coverage","title":"Estimated depth of coverage","text":"<p><code>depth-X1-X2-X3</code>: This is the estimated depth of coverage.</p> <p>The three distinct values represent different levels of nucleotide identity thresholds. </p> <ol> <li><code>X1</code> is the depth while allowing alignments of approximately &gt; 99% true nucleotide similarity (estimated using myloasm's SNP + k-mer formulation). </li> <li><code>X2</code> is the depth for &gt; 99.75% similarity.</li> <li><code>X3</code> is the depth for 100% similarity.</li> </ol>"},{"location":"output/#k-mer-multiplicity-and-duplication","title":"K-mer multiplicity and duplication","text":"<p><code>mult=X</code>: this is the estimated fraction of repetitiveness and useful for quality control. </p> <p>This is estimated by counting 21-mers across the contig and seeing how often they repeat on average after removing the most frequent and least frequent 10% of k-mers. </p> <ul> <li>Most complete prokaryotic genomes should have <code>mult-1.00</code>. </li> <li>Sometimes myloasm erroneously concatenates two similar strain genomes together. In this case, <code>mult</code> is &gt; 1.0 and indicative of contamination. </li> <li>Long reads often contain duplicate plasmids. Sometimes, a plasmid is erroneously duplicated or miscircularized, giving <code>mult</code> &gt; 1. </li> </ul> <p>If <code>mult</code> is &gt; 1.1, then <code>duplicated</code> is <code>possibly</code>. If &gt; 1.5, then <code>yes</code>. Otherwise, it is <code>no</code>. </p>"},{"location":"output/#the-final-assembly-graph-final_contig_graphgfa","title":"The final assembly graph: final_contig_graph.gfa","text":"<p>Each contig in <code>assembly_primary.fa</code> is a node in the final assembly graph, <code>final_contig_graph.gfa</code>. This is in modified GFA format and can be visualized with Bandage.</p> <p>Each <code>*.gfa</code> file has a corresponding <code>*.edges</code> file. The edges files gives more detailed information about contig-to-contig overlaps. </p>"},{"location":"output/#understanding-myloasms-gfa-assembly-graph-format","title":"Understanding myloasm's GFA assembly graph format","text":"<p>Myloasm's GFA file contains a header starting with <code>H</code>. Then, there is additional contig + read information that may be useful for manual curation.  </p>"},{"location":"output/#contig-information","title":"Contig information","text":"<pre><code>S       u165592ctg              LN:i:1034269    DP:f:25.0       DP2:f:24.0      DP3:f:23.0      MEDIAN_DP1:f:35.0\n</code></pre> <ul> <li>NOTE: <code>LN:i</code> is only an approximate length. This is the length before polishing.</li> <li><code>DP</code>, <code>DP2</code>, and <code>DP3</code> is the median of all <code>DP/2/3</code> values across the reads (see below). See here for more information on depth. </li> <li><code>MEDIAN_DP1</code> is the median-of-the-median-depth across all reads. <code>DP</code> is the median-of-the-minimum-depth across all reads. You can ignore the difference and use <code>DP</code> instead of <code>MEDIAN_DP1</code> most of the time. </li> </ul>"},{"location":"output/#read-information","title":"Read information:","text":"<pre><code>a       u165592ctg,0-28710      165592  0       SRRX.2+split0       -       28710   DP1:22,DP2:22,DP3:21,READ_LEN:43601,OL_LEN_NEXT:14808,SNP_SHARE_NEXT:216,SNP_DIFF_NEXT:1\na       u165592ctg,34-6529      1421634 28710   SRRX.1+split0+split0        +       6495    DP1:42,DP2:42,DP3:13,READ_LEN:21212,OL_LEN_NEXT:14629,SNP_SHARE_NEXT:129,SNP_DIFF_NEXT:0\n</code></pre> <ol> <li><code>a</code> indicates this is a read</li> <li><code>u165592ctg,0-28710</code> indicates that positions 0-28710 come from read <code>SRRX.2+split0</code> before polishing.</li> <li><code>165592</code> is the numeric read id. Myloasm assigns each read as a unique id. </li> <li><code>0</code> indicates this read's contribution to the unpolished contig starts at position 0</li> <li><code>SRRX.2+split0</code> - Read name. If myloasm thinks a read is chimeric, it may be split into several sub reads. For example, <code>split1</code> indicates the second chunk after splitting. Unsplit reads may also be denoted as <code>+split0</code>. There are two rounds of chimera splitting. </li> <li><code>-/+</code> - read orientation</li> </ol> <p>The last columns indicate the depth and overlap information of each read. See here for more information on varying depth values. </p> <ul> <li><code>OL_LEN_NEXT</code> - number of overlapping bases to the next read</li> <li><code>SNP_SHARE_NEXT</code> - number of estimated shared SNPs to the next read</li> <li><code>SNP_DIFF_NEXT</code> - number of estimated different SNPs to the next read. </li> </ul>"},{"location":"qc/","title":"QC discussion","text":""},{"location":"qc/#notes-on-misassemblies","title":"Notes on misassemblies","text":"<p>Like all other metagenome assemblers, myloasm can produce erroneous assemblies.</p> <p>Chimeric contigs: chimeric contigs consist of sequences from two or more genomes. This error can happen for a variety of reasons. The most common are:</p> <ul> <li>long interspecies shared genomic regions (e.g., horizontal gene transfer) can confuse assemblers</li> <li>extremely similar strains are hard to resolve, leading to strain-chimeric contigs</li> <li>chimeric long-reads due to technical sequencing artifacts can cause downstream errors in assembly</li> </ul> <p>Duplicated small contigs: we noticed that long-read assemblers can incorrectly duplicate small sequences (plasmids or viruses). </p> <p>The cause isn't always obvious, but we often found that a single long read can consist of multiple copies of the same plasmid. </p> <p>Prematurely circularized contigs: assemblers can prematurely circularize contigs, i.e., claim contigs are circular even though they are not. Algorithmically, this arises due to genome repeats.</p>"},{"location":"qc/#using-checkm2-on-long-prokaryotic-contigs","title":"Using CheckM2 on long prokaryotic contigs","text":"<p>The easiest way to filter out long (&gt;300 kb) erroneous prokaryotic contigs is to run CheckM2 on individual contigs. </p> <p>If a chimeric contig is long enough, it will often have high CheckM contamination due to the presence of duplicated marker genes from multiple organisms. </p> <p>To extract all contigs of length &gt;= X bp and run CheckM2, you can do (with mylotools)</p> <pre><code>cd myloasm_results\nmylotools extract-contigs --output-folder contigs_dir --min-contig-length X\ncheckm2 predict --input contigs_dir -x fa -o checkm2_results --threads 40\n</code></pre>"},{"location":"qc/#using-k-mer-multiplicity-statistics-for-duplicatesstrain-chimeras","title":"Using k-mer multiplicity statistics for duplicates/strain chimeras","text":"<p>Myloasm's fasta outputs have information about how often 21-mers are repeated (its multiplicity) within a contig: </p> <p>&gt;u123123ctg_XXX_duplicated-yes mult=2.00 &lt;- fasta record with k-mer multiplicity and duplication status.</p> <p>In our experience, prokaryotic contigs should almost always have average k-mer multiplicity near 1.00. If you have a very long contig (&gt; 1M bp) of multiplicity &gt; 1.05, it may be a chimera from multiple strains of a species. We set <code>duplicated</code> to <code>yes</code> or <code>possibly</code> then the multiplicity is high. </p> <p>For small genomes (e.g. viruses), the expected k-mer multiplicity may deviate from 1.00. However, a small contig with k-mer multiplicity &gt;&gt; 1 can be suspicious. A contig with k-mer multiplicity = 2, 3, or an integer multiple can indicate a perfectly duplicated contig. </p>"},{"location":"qc/#notes-on-circularized-contigs","title":"Notes on circularized contigs","text":"<p>For prokaryotic genomes, low CheckM2 completeness can indicate premature circularization. However: </p> <ul> <li>we have found that complete organelle genomes (mitochondria, plastids from microeukaryotes) can have non-trivial CheckM2 completeness (&gt; 30% but &lt; 90%) </li> <li>secondary chromosomes and genomes with multiple chromosomes can have lower completeness</li> <li>some clades of microbes have low CheckM2 completeness scores, even when they're complete</li> </ul> <p>The myloasm tag <code>circular-possibly</code> indicates lower confidence circular genomes (due to low coverage or assembly graph ambiguity), but these can often be complete genomes, especially if CheckM2 scores are good. </p>"},{"location":"qc_manual/","title":"Manual inspection with mylotools","text":"<p>Important</p> <p>We will be using mylotools. Make sure to install this first. </p>"},{"location":"qc_manual/#using-mylotools-plot-or-mylotools-report-to-manually-inspect-long-read-overlaps-and-find-chimeras","title":"Using <code>mylotools plot</code> or <code>mylotools report</code> to manually inspect long-read overlaps and find chimeras","text":"<p>We can generate QC plots to inspect GC content, read overlaps, and coverage information across a contig. You can generate an interactive report for all &gt; 300 kbp contigs with <code>mylotools report</code> with </p> <pre><code>cd myloasm_output\nmylotools report --output html_report\n</code></pre> <p>then use the dropdown menu to find a contig of interest. </p>"},{"location":"qc_manual/#generating-a-report-for-a-single-contig-of-interest","title":"Generating a report for a single contig of interest","text":"<p><code>mylotools report</code> is quite large. If you only want to plot a single contig of interest: e.g. <code>uXXXXXctg</code>, simply do</p> <pre><code>cd myloasm_output\nmylotools plot u2912759ctg\nls u2912759ctg_analysis.html\n</code></pre>"},{"location":"qc_manual/#understanding-qc-plots","title":"Understanding QC plots","text":""},{"location":"qc_manual/#panel-1-gc-content","title":"Panel 1: GC content","text":"<ul> <li>The first panel is the GC content averaged across windows. </li> <li>Prokaryotic genomes should have relatively consistent GC content across the genome. If you see a sharp change in GC content, it may indicate a chimeric breakpoint. </li> </ul>"},{"location":"qc_manual/#panel-2-cumulative-gc-skew","title":"Panel 2: Cumulative GC Skew","text":"<ul> <li>See this article or this one for more information about GC skew.</li> <li>Many prokaryotes have a peak and a trough, indicating origin and terminus of replication. </li> </ul>"},{"location":"qc_manual/#panel-3-coverage-across-the-genome","title":"Panel 3: Coverage across the genome","text":"<ul> <li>Each dot is a read that the contig was constructed from.</li> <li>There are 3 different read coverage values. See here for more information about what they mean. DP1 is the most permissive coverage value whereas DP3 indicates exact coverage (perfect alignments). </li> </ul>"},{"location":"qc_manual/#panel-4-read-overlap-information-within-assembly-graph","title":"Panel 4: Read overlap information within assembly graph","text":"<ul> <li>Each dot is a read overlap. Statistics about lengths/the read IDs are shown.</li> <li>The colour indicates the number of shared/differing SNPs between the reads. An ideal contig involves no differing SNPs between reads, but sometimes this is impossible (e.g. high levels of recombination). </li> </ul>"},{"location":"qc_manual/#finding-chimeric-breakpoints-from-the-plot-graph","title":"Finding chimeric breakpoints from the <code>plot</code> graph","text":"<p>The x-axis are roughly shared across all of the four plots. The first two panels x-axis are for the polished contig. The bottom two are the raw, unpolished contig. These differ very slightly. </p> <p>To find breakpoints, we can look at points on the x-axis where there are unexpected changes.</p> <ol> <li>GC content should be roughly constant across a prokaryotic genome</li> <li>GC skew often has a single peak and a trough (see here)</li> <li>Coverage should be constant across a contig. However, DP1 (green) and DP2 (yellow) can vary significantly -- inexact repeat regions (across strains or species) can elevate the DP1/DP2 values.</li> <li>Read overlaps should be long. Small overlaps can be suspicious. High # of SNP differences are not ideal, but sometimes can not be avoided. </li> </ol>"},{"location":"qc_manual/#case-study-a-contaminated-contig","title":"Case study: a contaminated contig","text":"<p>The below graph is for a 99% complete but 18% contaminated contig (estimated by CheckM2) from an anaerobic digester metagenome. We see irregularities at around the 2.6 Mbp position.</p> <p></p> <p>A few issues occur:</p> <ol> <li>The GC content has a noticeable downward shift</li> <li>The cumulative GC skew goes up and down again</li> <li>The DP1/DP2 coverages are variable and high, whereas DP1/DP2 before the breakpoint are consistently low</li> </ol> <p>This is quite strong evidence for a chimeric join. After removing the bases from 2.6 Mbp onward and rerunning CheckM2, we get a 97% complete and 0% contaminated contig, confirming our suspicion. </p> <p>Note</p> <p>Around the breakpoint, all overlaps have length &gt; 8kbp and are almost perfect. This was probably a recent horizontally transferred region. Even with long reads, metagenomic assembly is still extremely difficult. </p>"},{"location":"results/","title":"Preliminary Results","text":"<p>Important</p> <p>The preprint is now out! The below results are slightly out of date. </p>"},{"location":"results/#algorithm-outline","title":"Algorithm outline","text":"<p>At a high level, myloasm uses a string graph approach. Briefly, myloasm:</p> <ol> <li>aligns reads-to-reads, splits chimeric reads, and estimates coverage per read</li> <li>uses polymorphic, strain-specific k-mers (we call them SNPmers) to find true sequence divergence between reads </li> <li>obtains a high-resolution overlap graph and finds walks (contigs) with consistent coverage using an annealing-inspired optimization approach</li> <li>aligns reads-to-contigs and polishes using partial order alignment (SPOA)</li> </ol>"},{"location":"results/#results","title":"Results","text":"Fig. 1. Metagenome-assembled genome (MAG) recovery for Nanopore R10.4 simplex + PacBio HiFi sequencing datasets. Alignment + binning was done with minimap2 and SemiBin2; results are evaulated with CheckM2.   Fig. 2. Completeness + contamination results from CheckM2 on individual contigs for the different assemblers. Dashed line indicates circular complete MAGs (&gt; 90% complete, &lt; 5% contaminated and circular)."},{"location":"results/#dataset-accessions","title":"Dataset accessions","text":"Dataset (ONT R10.4) Accession Dataset (HiFi) Accession Oral 1  (Kiguchi et al.) DRR582205 Hot Spring  (Kato et al.) DRR290133 Oral 2    (Kiguchi et al.) DRR582179 Anaerobic Digester (Benoit et al.) ERR10905741 Gut 1   (Minich et al.) SRR29980972 Chicken Gut    (Zhang et al.) SRR19683891 Gut 2 (Minich et al.) SRR29980959 Human Gut (Gehrig et al.) SRR15489018 Gut 3    (Minich et al.) SRR29980980 P. Seawater  (Priest et al.) ERR4920901 S. Seawater (Sidhu et al.) ERR9769281"},{"location":"secondary/","title":"Secondary files","text":"<pre><code>\u251c\u2500\u2500 myloasm_(DATE + TIME).log\n\u251c\u2500\u2500 assembly_graphs/\n\u2502   \u251c\u2500\u2500 unitig_graph-0.gfa\n\u2502   \u251c\u2500\u2500 after_light_cleaning-1.gfa\n\u2502   \u251c\u2500\u2500 after_walk_heavy_cleaned-2.gfa\n\u2502   \u2514\u2500\u2500 small_and_tip_bubble-3.gfa\n\u251c\u2500\u2500 0-cleaning_and_unitigs/\n\u2502   \u2514\u2500\u2500 Read cleaning + mapping files\n\u251c\u2500\u2500 1-light_resolve/\n\u2502   \u2514\u2500\u2500 Initial graph cleaning files\n\u251c\u2500\u2500 2-heavy_path_resolve/\n\u2502   \u2514\u2500\u2500 Heavy graph cleaning files\n\u251c\u2500\u2500 3-mapping/\n\u2502   \u251c\u2500\u2500 map_to_unitigs.paf.gz\n\u2502   \u2514\u2500\u2500 low_quality_regions.bed\n\u251c\u2500\u2500 binary_temp/\n\u2502   \u2514\u2500\u2500 Large binary files \n\u2514\u2500\u2500 alternate_assemblies/\n    \u251c\u2500\u2500 duplicated_contigs.fa\n    \u2514\u2500\u2500 assembly_alternate.fa\n</code></pre>"},{"location":"secondary/#myloasm_log","title":"<code>myloasm_*.log</code>","text":"<p>Logging information. Has some extra information over just the stderr output. </p>"},{"location":"secondary/#assembly_graphs","title":"<code>assembly_graphs/</code>","text":"<p>Contains intermediate assembly graphs in GFA format. See here for more info about myloasm's GFA outputs.</p> <ul> <li><code>unitig_graph-0.gfa</code> - raw unitigs with minimal cleaning. Usually extremely messy. </li> <li><code>after_light_cleaning-1.gfa</code> - lightly cleaned unitigs after removing relatively small overlaps</li> <li><code>after_walk_heavy_cleaned-2.gfa</code> - heavily cleaned unitigs after using coverage information + removing large overlaps.</li> <li><code>small_and_tip_bubble-3.gfa</code> - further cleaning of tips and rescuing some small circular contigs</li> </ul>"},{"location":"secondary/#0-cleaning_and_unitigs","title":"<code>0-cleaning_and_unitigs/</code>","text":"<p>These are files during the initial read-to-read mapping, read containment, and graph construction steps. </p> <ul> <li><code>all-cont.txt.gz</code> - containment status of all reads</li> <li><code>overlaps.txt.gz</code> - information about overlaps between non-contained reads</li> <li><code>read_coverages.txt.gz</code> - this file gives information about reads that are chimeric and where they get split</li> <li><code>remap_temp/</code> - we do multiple rounds of splitting and overlapping; these files are for the second round. </li> </ul>"},{"location":"secondary/#1-light_resolve","title":"<code>1-light_resolve/</code>","text":"<p>These files show intermediate assembly graphs during the initial, light graph cleaning iterations. </p>"},{"location":"secondary/#2-heavy_path_resolve","title":"<code>2-heavy_path_resolve/</code>","text":"<p>These files show intermediate assembly graphs and information about the inferred edge weights during the heavier graph cleaning iterations. </p> <p>The graphs look like: <code>heavy-m15-t0.5-r0.5.gfa</code>. Here, larger <code>m</code> indicates larger topological graph simplifications. <code>t</code> is the temperature (lower is more aggressive). <code>r</code> is the edge weight cut ratio (higher is more aggressive). </p>"},{"location":"secondary/#3-mapping","title":"<code>3-mapping/</code>","text":"<p>These files show how read (or contigs) map to the final unpolished contigs. We use \"unitigs\" and \"contigs\" interchangeably here. </p> <ul> <li><code>map_to_unitigs.paf.gz</code> - mapping of reads to unpolished unitigs in PAF format. There are additional columns indicating some SNP information. </li> <li><code>dereplicate_unitigs.paf.gz</code> - we map intermediate unitigs to other unitigs and filter out unitigs that map perfectly, prior to polishing. </li> <li><code>low_quality_regions.bed</code> (since v0.3.0) - regions with low coverage or possible chimericism found during polishing. This is generated from parsing <code>map_to_unitigs.paf.gz</code>. Some of these contigs will be filtered out in subsequent steps. This may be useful in parsing out poorly polished regions of a genome.</li> </ul>"},{"location":"secondary/#binary_temp","title":"<code>binary_temp/</code>","text":"<p>These are large binary files that are dumped by myloasm. This is useful for rerunning myloasm after a failure by doing <code>myloasm -o output_dir exist</code> -- note the magic keyword <code>exist</code>. </p> <p>If you don't want these files to be output, use the <code>--clean-dir</code>. </p>"},{"location":"secondary/#alternate_assemblies","title":"<code>alternate_assemblies/</code>","text":"<ul> <li> <p>If a contig is &gt; 99.9% similar and contained in another contig, it is put into <code>duplicated_contigs.fa</code>. </p> </li> <li> <p>If a contig is &gt; 99% similar but &lt; 99.9% similar and contained in other contigs, we put it into <code>assembly_alternate.fa</code>. </p> </li> </ul>"},{"location":"usage/","title":"Quick usage","text":""},{"location":"usage/#nanopore-r104","title":"Nanopore R10.4","text":"<pre><code>myloasm reads1.fq reads2.fq reads3.fq -o output_directory -t 50\n</code></pre> <ul> <li>Positional inputs are reads. Multiple reads are concatenated. Myloasm uses base qualities, so fastq files are preferred over fasta.</li> <li><code>-o</code>: results directory; a new directory is made if not present.</li> <li><code>-t</code>: number of threads</li> </ul>"},{"location":"usage/#pacbio-hifi","title":"PacBio HiFi","text":"<pre><code>myloasm reads1.fq reads2.fq reads3.fq -o output_directory -t 50 --hifi\n</code></pre> <ul> <li><code>--hifi</code>: append the HiFi flag is using HiFi reads. Everything else is the same. </li> </ul>"},{"location":"usage/#optional-visualizing-contigs-from-myloasm","title":"(Optional) Visualizing contigs from myloasm","text":"<p>We provide a set of tools called mylotools for quality control, processing, and visualization of myloasm outputs. </p> <pre><code># if you haven't installed mylotools\nconda install -c bioconda mylotools\n\ncd output_directory\nmylotools report --output report_and_plots\nls report_and_plots/contig_summary_report.html\n</code></pre>"},{"location":"usage/#useful-common-parameters","title":"Useful common parameters","text":"<ul> <li><code>--clean-dir</code> - myloasm dumps large intermediate files to the results directory by default to enable rerunning from intermediate failure. Specify this flag to not dump these large files. </li> <li><code>--min-reads-contig</code> - myloasm outputs all contigs, even those with a single read, by default. Increase to retain only contigs with &gt;= X reads. </li> <li><code>-c</code> - increase this to reduce memory and increase speed with some sensitivity loss. Should be &lt;= 15. [default = 11]</li> <li><code>--quality-value-cutoff</code> - myloasm retains reads with only &gt;= X estimated accuracy for graph building. Increasing may create more accurate assembly graphs at a loss of sensitivity. </li> <li><code>--min-ol</code> - Allow overlaps of length &gt;= X for assembly graph construction. The default is quite aggressive and more sensitive at low coverage, but may lead to more false positives. Consider increasing for more accuracy for high coverage contigs. </li> <li><code>--bloom-filter-size</code> - The Bloom filter size in GB. Myloasm uses a bloom filter for reducing memory during the k-mer counting stage. Consider increasing for large metagenomes (&gt; 100 Gbp)</li> <li><code>--aggressive-bloom</code> - Use a more aggressive Bloom filtering strategy. Makes results non-deterministic, but saves some memory during initial k-mer counting step.</li> </ul>"}]}