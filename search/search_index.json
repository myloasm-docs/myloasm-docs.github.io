{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Myloasm is a de novo metagenome assembler for long-read sequencing data. It takes sequencing reads and outputs polished contigs in a single command. </p> <p>Myloasm works with:</p> <ul> <li>Nanopore R10 simplex reads with &gt; ~97% accuracy (basecalled in sup or hac mode)</li> <li>PacBio HiFi reads</li> </ul> <p>Installation and Usage: See the Install and Usage sections on the navigation side bar. Source code is available at the GitHub repo.</p>"},{"location":"#why-myloasm","title":"Why myloasm?","text":"<p>Results: Here are some preliminary results for myloasm until the preprint officially comes out.</p> <p>Philosophy: Myloasm was designed to take advantage of modern long reads. Even the noisiest modern long reads (e.g., nanopore simplex R10) have become quite accurate. Myloasm uses a new algorithmic framework that enables high-resolution assembly from this data.</p> <p>Strengths: myloasm can </p> <ul> <li>often assemble similar (intraspecies) strains better than other nanopore assemblers</li> <li>take advantage of very long reads better than de Bruijn graph approaches</li> <li>obtain contiguous assemblies in even complex, highly heterogeneous metagenomes</li> </ul> <p>Limitations: myloasm may</p> <ul> <li>occasionally produce chimeric misassembled contigs, like all metagenome assemblers.<ul> <li>we provide extra debugging information for manual curation; see the quality control guide.</li> </ul> </li> <li>use more memory than other assemblers. Currently, a ~200 gigabase long-read human gut sample takes ~450 GB of RAM. </li> </ul>"},{"location":"#issues-questions-and-discussions","title":"Issues, questions, and discussions","text":"<ul> <li>Found a bug or have an issue? Go to https://github.com/bluenote-1577/myloasm/issues </li> <li>Have a general question or discussion topic? Go to https://github.com/bluenote-1577/myloasm/discussions</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>Jim Shaw, Maximillian Marin, and Heng Li. High-resolution metagenome assembly for modern long reads with myloasm. bioRxiv (2025).</p>"},{"location":"cmd/","title":"Full command-line help for <code>myloasm</code>","text":"<p>myloasm - high-resolution metagenomic assembly with noisy long reads. See online documentation for full options. </p> <p>EXAMPLE (Nanopore R10): myloasm nanopore_reads.fq.gz -o output_directory -t 50</p> <p>EXAMPLE (PacBio HiFi): myloasm pacbio_reads.fq.gz -o output_directory -t 50 --hifi</p> <p>Usage: <code>myloasm [OPTIONS] &lt;FASTQ/FASTA (.gz)&gt;...</code></p>"},{"location":"cmd/#arguments","title":"Arguments:","text":"<ul> <li><code>&lt;FASTQ/FASTA (.gz)&gt;</code> \u2014 Input read file(s) -- multiple files are concatenated</li> </ul>"},{"location":"cmd/#basic-algorithmic-parameters","title":"Basic Algorithmic Parameters:","text":"<ul> <li> <p><code>-c</code>, <code>--c &lt;C&gt;</code> \u2014 Compression ratio (1/c k-mers selected). Must be &lt;= 15  [<code>11</code>] </p> </li> <li> <p><code>--quality-value-cutoff &lt;QUALITY_VALUE_CUTOFF&gt;</code> \u2014 Disallow reads with &lt; % identity for graph building (estimated from base qualities)  [<code>90</code>] </p> </li> <li> <p><code>--min-ol &lt;MIN_OL&gt;</code> \u2014 Minimum overlap length for graph construction  [<code>500</code>] </p> </li> <li> <p><code>-b</code>, <code>--bloom-filter-size &lt;BLOOM_FILTER_SIZE&gt;</code> \u2014 Bloom filter size in GB. Increase for massive datasets  [<code>10</code>] </p> </li> <li> <p><code>--aggressive-bloom</code> \u2014 More aggressive filtering of low-abundance k-mers. May be non-deterministic</p> </li> <li><code>-k</code>, <code>--kmer-size &lt;KMER_SIZE&gt;</code> \u2014 K-mer size (must be odd and &lt; 24)  [<code>21</code>] </li> </ul>"},{"location":"cmd/#technology-presets","title":"Technology Presets:","text":"<ul> <li><code>--nano-r10</code> \u2014 (DEFAULT) R10 nanopore mode for sup/hac data (&gt; ~97% median accuracy). Specifying this flag does not do anything for now</li> <li><code>--nano-r9</code> \u2014 R9 (old nanopore) mode for low (~90%) accuracy reads. Experimental</li> <li><code>--hifi</code> \u2014 PacBio HiFi mode -- assumes less chimericism and higher accuracy</li> </ul>"},{"location":"cmd/#output-thresholds","title":"Output thresholds:","text":"<ul> <li> <p><code>--min-reads-contig &lt;MIN_READS_CONTIG&gt;</code> \u2014 Output contigs with &gt;= this number of reads  [<code>1</code>] </p> </li> <li> <p><code>--singleton-coverage-threshold &lt;SINGLETON_COVERAGE_THRESHOLD&gt;</code> \u2014 Remove singleton contigs with &lt;= this estimated coverage depth (DP1 coverage; 99% identity coverage)  [<code>3</code>] </p> </li> <li> <p><code>--secondary-coverage-threshold &lt;SECONDARY_COVERAGE_THRESHOLD&gt;</code> \u2014 Remove contigs with &lt;= this estimated coverage depth and &lt;= 2 reads (DP1 coverage; 99% identity coverage)  [<code>1</code>] </p> </li> <li> <p><code>--absolute-coverage-threshold &lt;ABSOLUTE_COVERAGE_THRESHOLD&gt;</code> \u2014 Remove all contigs with &lt;= this estimated coverage depth (DP1 coverage; 99% identity coverage)</p> </li> </ul>"},{"location":"cmd/#graph-parameters-advanced","title":"Graph Parameters (advanced):","text":"<ul> <li> <p><code>--small-bubble-threshold &lt;SMALL_BUBBLE_THRESHOLD&gt;</code> \u2014 Base bubble popping length threshold; this gets multiplied by 5-30x during progressive graph cleaning  [<code>50000</code>] </p> </li> <li> <p><code>--z-edge-threshold &lt;Z_EDGE_THRESHOLD&gt;</code> \u2014 Cut z-edges that are &lt; this times smaller than the adjacent overlaps  [<code>1</code>] </p> </li> <li> <p><code>--tip-length-cutoff &lt;TIP_LENGTH_CUTOFF&gt;</code> \u2014 Base length of tip to remove; this gets multiplied by 5-30x during simplification  [<code>20000</code>] </p> </li> <li> <p><code>--tip-read-cutoff &lt;TIP_READ_CUTOFF&gt;</code> \u2014 Number of reads in tips to remove; this gets multiplied by 5-30x during simplification  [<code>3</code>] </p> </li> <li> <p><code>--max-bubble-threshold &lt;MAX_BUBBLE_THRESHOLD&gt;</code> \u2014 Maximum bubble length to pop; keep alternates  [<code>500000</code>] </p> </li> </ul>"},{"location":"cmd/#miscellaneous-options","title":"Miscellaneous Options:","text":"<ul> <li> <p><code>--no-polish</code> \u2014 No polishing (not recommended)  [<code>false</code>] </p> </li> <li> <p><code>--no-snpmers</code> \u2014 Disable usage of SNPmers (not recommended)  [<code>false</code>] </p> </li> </ul>"},{"location":"cmd/#options","title":"Options:","text":"<ul> <li> <p><code>-o</code>, <code>--output-dir &lt;OUTPUT_DIR&gt;</code> \u2014 Output directory for results; created if it does not exist  [<code>myloasm-out</code>] </p> </li> <li> <p><code>-t</code>, <code>--threads &lt;THREADS&gt;</code> \u2014 Number of threads to use for processing  [<code>20</code>] </p> </li> <li> <p><code>--clean-dir</code> \u2014 Do not dump large intermediate data to disk (intermediate data is useful for rerunning)</p> </li> <li><code>-l</code>, <code>--log-level &lt;LOG_LEVEL&gt;</code> \u2014 Verbosity level. Warning: trace is very verbose  [<code>debug</code>] </li> </ul> <p>Possible values: <code>error</code>, <code>warn</code>, <code>info</code>, <code>debug</code>, <code>trace</code></p> <ul> <li><code>--markdown-help</code> \u2014 Print this markdown document</li> </ul>"},{"location":"cmd/#overlap-parameters-advanced","title":"Overlap Parameters (advanced):","text":"<ul> <li> <p><code>--read-map-batch-size &lt;READ_MAP_BATCH_SIZE&gt;</code> \u2014 Batch size of indexing for read-to-read mapping and overlap stage  [<code>1000000</code>] </p> </li> <li> <p><code>--snpmer-threshold-strict &lt;SNPMER_THRESHOLD_STRICT&gt;</code> \u2014 Snpmer identity threshold for containment and strict overlaps  [<code>100</code>] </p> </li> <li> <p><code>--snpmer-threshold-lax &lt;SNPMER_THRESHOLD_LAX&gt;</code> \u2014 Snpmer identity threshold for relaxed overlaps  [<code>99</code>] </p> </li> <li> <p><code>--snpmer-error-rate-lax &lt;SNPMER_ERROR_RATE_LAX&gt;</code> \u2014 Binomial test error parameter for relaxed overlaps  [<code>0.025</code>] </p> </li> <li> <p><code>--snpmer-error-rate-strict &lt;SNPMER_ERROR_RATE_STRICT&gt;</code> \u2014 Binomial test error parameter strict overlaps  [<code>0</code>] </p> </li> <li> <p><code>--contain-subsample-rate &lt;CONTAIN_SUBSAMPLE_RATE&gt;</code> \u2014 Relaxed compression ratio during containment; must be &gt; c  [<code>44</code>] </p> </li> <li> <p><code>--absolute-minimizer-cut-ratio &lt;ABSOLUTE_MINIMIZER_CUT_RATIO&gt;</code> \u2014 Cut overlaps with &gt; (c * this) number of bases between minimizers on average  [<code>8</code>] </p> </li> <li> <p><code>--relative-minimizer-cut-ratio &lt;RELATIVE_MINIMIZER_CUT_RATIO&gt;</code> \u2014 Cut overlaps with &gt; (this) times more bases between minimizers than the best overlap on average  [<code>5</code>] </p> </li> <li> <p><code>--disable-error-overlap-rescue</code> \u2014 Disables a SNPmer error overlap rescue heuristic during graph construction</p> </li> <li><code>--maximal-end-fuzz &lt;MAXIMAL_END_FUZZ&gt;</code> \u2014 Soft clips with &lt; this # of bases are allowed for alignment  [<code>300</code>] </li> </ul> <p>     This document was generated automatically by     <code>clap-markdown</code>. </p>"},{"location":"install/","title":"Install","text":""},{"location":"install/#conda-install-x86-64-avx2-instructions","title":"Conda install (x86-64 + AVX2 instructions)","text":"<pre><code>mamba install -c bioconda myloasm\n</code></pre>"},{"location":"install/#portable-x86-64-avx2-binary","title":"Portable x86-64 + AVX2 binary","text":"<pre><code>wget https://github.com/bluenote-1577/myloasm/releases/download/v0.2.0/myloasm-0.2.0-x86_64-avx2\nchmod +x myloasm-0.2.0-x86_64-avx2\n./myloasm-0.2.0-x86_64-avx2\n</code></pre> <ul> <li>This binary is not static but dynamically linked to older version of shared libraries (GLIBC and GLIBCXX) built on CentOS 7.</li> <li>Requires AVX2 instructions and x86-64 architectures (most linux machines). </li> </ul>"},{"location":"install/#build-from-source","title":"Build from source","text":"<p>Requirements:</p> <ul> <li>Rust programming language &gt;= v1.85</li> <li>gcc 4.8+ or clang 3.4+</li> <li>cmake 3.5+</li> </ul>"},{"location":"install/#x86-64-linux-systems-with-avx2-most-modern-machines","title":"x86-64 linux systems with AVX2 (most modern machines)","text":"<pre><code>git clone https://github.com/bluenote-1577/myloasm --recurse-submodules  \ncd myloasm\ncargo install --path . \nmyloasm -h\n</code></pre> <p>Compiling from source should take a few minutes.</p>"},{"location":"install/#sse2-but-no-avx2-instructions","title":"SSE2 but no AVX2 instructions","text":"<pre><code>cargo install --path . --features=sse --no-default-features\n</code></pre>"},{"location":"install/#arm-neon-instructions","title":"ARM NEON instructions","text":"<p>Warning</p> <p>Compilation should work on ARM architectures supporting NEON instructions. However, runtime performance may degrade for the polishing step.</p> <pre><code>cargo install --path . --features=neon --no-default-features\n</code></pre>"},{"location":"output/","title":"Output directory","text":"<pre><code>myloasm_output \n    \u251c\u2500\u2500 assembly_primary.fa &lt;-- CONTIGS\n    \u251c\u2500\u2500 final_contig_graph.(gfa/edges) &lt;-- GRAPH \n    \u2514\u2500\u2500 OTHER STUFF (secondary files)\n</code></pre> <ul> <li>The main contig file: assembly_primary.fa<ul> <li>Contig fasta record label definition<ul> <li>Circularity</li> <li>Estimated depth of coverage </li> <li>K-mer multiplicity</li> </ul> </li> </ul> </li> <li>The final assembly graph: final_contig_graph.gfa<ul> <li>Understanding myloasm's GFA assembly graph format <ul> <li>Contig information </li> <li>Read information </li> </ul> </li> </ul> </li> </ul>"},{"location":"output/#the-main-contig-file-assembly_primaryfa","title":"The main contig file: assembly_primary.fa","text":"<p>These are the main polished contigs to be used for downstream analysis most of the time. </p>"},{"location":"output/#contig-fasta-record-label-definition","title":"Contig fasta record label definition","text":"<p>The fasta records looks like this:</p> <p>&gt;u2658272ctg_len-2275750_circular-possibly_depth-10-9-9_duplicated-no mult=1.00</p> <p><code>u2658272ctg</code> is the identifier and <code>len-X</code> is the length in nucleotides. There is also information about the circularity, depth of coverage, and repetitiveness of the contig. </p>"},{"location":"output/#circularity","title":"Circularity","text":"<p><code>circular-X</code>: X is either <code>yes</code>, <code>no</code>, or <code>possibly</code>. </p> <p>If a contig has a self loop in the assembly graph and </p> <ol> <li>has average depth &gt; 5x and </li> <li>has no other connections (i.e., consists of a single node and a single edge) </li> </ol> <p>then it is <code>yes</code>. </p> <p>If it has a self loop, but (1) or (2) fails above, then it is <code>possibly</code>. Otherwise, it is <code>no</code>. </p>"},{"location":"output/#estimated-depth-of-coverage","title":"Estimated depth of coverage","text":"<p><code>depth-X1-X2-X3</code>: This is the estimated depth of coverage.</p> <p>The three distinct values represent different levels of nucleotide identity thresholds. </p> <ol> <li><code>X1</code> is the depth while allowing alignments of approximately &gt; 99% true nucleotide similarity (estimated using myloasm's SNP + k-mer formulation). </li> <li><code>X2</code> is the depth for &gt; 99.75% similarity.</li> <li><code>X3</code> is the depth for 100% similarity.</li> </ol>"},{"location":"output/#k-mer-multiplicity-and-duplication","title":"K-mer multiplicity and duplication","text":"<p><code>mult=X</code>: this is the estimated fraction of repetitiveness and useful for quality control. </p> <p>This is estimated by counting 21-mers across the contig and seeing how often they repeat on average after removing the most frequent and least frequent 10% of k-mers. </p> <ul> <li>Most complete prokaryotic genomes should have <code>mult-1.00</code>. </li> <li>Sometimes myloasm erroneously concatenates two similar strain genomes together. In this case, <code>mult</code> is &gt; 1.0 and indicative of contamination. </li> <li>Long reads often contain duplicate plasmids. Sometimes, a plasmid is erroneously duplicated or miscircularized, giving <code>mult</code> &gt; 1. </li> </ul> <p>If <code>mult</code> is &gt; 1.1, then <code>duplicated</code> is <code>possibly</code>. If &gt; 1.5, then <code>yes</code>. Otherwise, it is <code>no</code>. </p>"},{"location":"output/#the-final-assembly-graph-final_contig_graphgfa","title":"The final assembly graph: final_contig_graph.gfa","text":"<p>Each contig in <code>assembly_primary.fa</code> is a node in the final assembly graph, <code>final_contig_graph.gfa</code>. This is in modified GFA format and can be visualized with Bandage.</p> <p>Each <code>*.gfa</code> file has a corresponding <code>*.edges</code> file. The edges files gives more detailed information about contig-to-contig overlaps. </p>"},{"location":"output/#understanding-myloasms-gfa-assembly-graph-format","title":"Understanding myloasm's GFA assembly graph format","text":"<p>Myloasm's GFA file contains a header starting with <code>H</code>. Then, there is additional contig + read information that may be useful for manual curation.  </p>"},{"location":"output/#contig-information","title":"Contig information","text":"<pre><code>S       u165592ctg              LN:i:1034269    DP:f:25.0       DP2:f:24.0      DP3:f:23.0      MEDIAN_DP1:f:35.0\n</code></pre> <ul> <li>NOTE: <code>LN:i</code> is only an approximate length. This is the length before polishing.</li> <li><code>DP</code>, <code>DP2</code>, and <code>DP3</code> is the median of all <code>DP/2/3</code> values across the reads (see below). See here for more information on depth. </li> <li><code>MEDIAN_DP1</code> is the median-of-the-median-depth across all reads. <code>DP</code> is the median-of-the-minimum-depth across all reads. You can ignore the difference and use <code>DP</code> instead of <code>MEDIAN_DP1</code> most of the time. </li> </ul>"},{"location":"output/#read-information","title":"Read information:","text":"<pre><code>a       u165592ctg,0-28710      165592  0       SRRX.2+split0       -       28710   DP1:22,DP2:22,DP3:21,READ_LEN:43601,OL_LEN_NEXT:14808,SNP_SHARE_NEXT:216,SNP_DIFF_NEXT:1\na       u165592ctg,34-6529      1421634 28710   SRRX.1+split0+split0        +       6495    DP1:42,DP2:42,DP3:13,READ_LEN:21212,OL_LEN_NEXT:14629,SNP_SHARE_NEXT:129,SNP_DIFF_NEXT:0\n</code></pre> <ol> <li><code>a</code> indicates this is a read</li> <li><code>u165592ctg,0-28710</code> indicates that positions 0-28710 come from read <code>SRRX.2+split0</code> before polishing.</li> <li><code>165592</code> is the numeric read id. Myloasm assigns each read as a unique id. </li> <li><code>0</code> indicates this read's contribution to the unpolished contig starts at position 0</li> <li><code>SRRX.2+split0</code> - Read name. If myloasm thinks a read is chimeric, it may be split into several sub reads. For example, <code>split1</code> indicates the second chunk after splitting. Unsplit reads may also be denoted as <code>+split0</code>. There are two rounds of chimera splitting. </li> <li><code>-/+</code> - read orientation</li> </ol> <p>The last columns indicate the depth and overlap information of each read. See here for more information on varying depth values. </p> <ul> <li><code>OL_LEN_NEXT</code> - number of overlapping bases to the next read</li> <li><code>SNP_SHARE_NEXT</code> - number of estimated shared SNPs to the next read</li> <li><code>SNP_DIFF_NEXT</code> - number of estimated different SNPs to the next read. </li> </ul>"},{"location":"qc/","title":"QC Overview","text":""},{"location":"qc/#mylotools-scripts-for-myloasm-outputs","title":"mylotools - scripts for myloasm outputs","text":"<p>We provide a set of tools for working with myloasm assemblies called mylotools. We discuss how to use <code>mylotools</code> below for quality control. To install mylotools, do</p> <pre><code>git clone https://github.com/bluenote-1577/mylotools\ncd mylotools\n\n## assuming you have python3 installed\npip install . \n\nmylotools -h\n\n## plot and inspect contigs\ncd myloasm_results\nmylotools plot u32910ctg\n\nls u32910ctg_analysis.html\n</code></pre>"},{"location":"qc/#notes-on-misassemblies","title":"Notes on misassemblies","text":"<p>Like all other metagenome assemblers, myloasm can produce erroneous assemblies.</p> <p>Chimeric contigs: chimeric contigs consist of sequences from two or more genomes. This error can happen for a variety of reasons. The most common are:</p> <ul> <li>long interspecies shared genomic regions (e.g., horizontal gene transfer) can confuse assemblers</li> <li>extremely similar strains are hard to resolve, leading to strain-chimeric contigs</li> <li>chimeric long-reads due to technical sequencing artifacts can cause downstream errors in assembly</li> </ul> <p>Duplicated small contigs: we noticed that long-read assemblers can incorrectly duplicate small sequences (plasmids or viruses). </p> <p>The cause isn't always obvious, but we often found that a single long read can consist of multiple copies of the same plasmid. </p> <p>Prematurely circuarlized contigs: assemblers can prematurely circularize contigs, i.e., claim contigs are circular even though they are not. Algorithmically, this arises due to genome repeats.</p>"},{"location":"qc/#quality-control-qc-guides","title":"Quality control (QC) guides","text":""},{"location":"qc/#guide-1-qc-statistics-and-interpretation","title":"Guide 1: QC statistics and interpretation","text":"<p>See here for some notes on how to obtain and interpret QC statistics from myloasm.</p>"},{"location":"qc/#guide-2-manual-inspection-of-myloasms-outputs-with-mylotools-and-decontaminating-contigs","title":"Guide 2: Manual inspection of myloasm's outputs with mylotools and decontaminating contigs","text":"<p>See here for how the <code>mylotools plot</code> utility can provide overlap/coverage/GC information.</p>"},{"location":"qc_manual/","title":"Manual inspection with mylotools","text":"<p>Important</p> <p>We will be using mylotools, a set of scripts for manipulating myloasm's outputs. </p>"},{"location":"qc_manual/#using-mylotools-plot-to-manually-inspect-long-read-overlaps-and-find-chimeras","title":"Using <code>mylotools plot</code> to manually inspect long-read overlaps and find chimeras","text":"<p>We provide a plotting utility command called <code>mylotools plot</code> to inspect GC content, read overlaps, and coverage information across a contig. Given a contig of interest: e.g. <code>uXXXXXctg</code>, simply do</p> <pre><code># you should be in the results directory\ncd myloasm_results \n\nmylotools plot u2912759ctg\nls u2912759ctg_analysis.html\n</code></pre>"},{"location":"qc_manual/#mylotools-plot-output","title":"<code>mylotools plot</code> output","text":"<p>Open the file <code>u2912759ctg_analysis.html</code> in a browser and it will look like:</p> <p></p>"},{"location":"qc_manual/#panel-1-gc-content","title":"Panel 1: GC content","text":"<ul> <li>The first panel is the GC content averaged across windows. </li> <li>Prokaryotic genomes should have relatively consistent GC content across the genome. If you see a sharp change in GC content, it may indicate a chimeric breakpoint. </li> </ul>"},{"location":"qc_manual/#panel-2-cumulative-gc-skew","title":"Panel 2: Cumulative GC Skew","text":"<ul> <li>See this article or this one for more information about GC skew.</li> <li>Many prokaryotes have a peak and a trough, indicating origin and terminus of replication. </li> </ul>"},{"location":"qc_manual/#panel-3-coverage-across-the-genome","title":"Panel 3: Coverage across the genome","text":"<ul> <li>Each dot is a read that the contig was constructed from.</li> <li>There are 3 different read coverage values. See here for more information about what they mean. DP1 is the most permissive coverage value whereas DP3 indicates exact coverage (perfect alignments). </li> </ul>"},{"location":"qc_manual/#panel-4-read-overlap-information-within-assembly-graph","title":"Panel 4: Read overlap information within assembly graph","text":"<ul> <li>Each dot is a read overlap. Statistics about lengths/the read IDs are shown.</li> <li>The colour indicates the number of shared/differing SNPs between the reads. An ideal contig involves no differing SNPs between reads, but sometimes this is impossible (e.g. high levels of recombination). </li> </ul>"},{"location":"qc_manual/#finding-chimeric-breakpoints-from-the-plot-graph","title":"Finding chimeric breakpoints from the <code>plot</code> graph","text":"<p>The x-axis are roughly shared across all of the four plots. The first two panels x-axis are for the polished contig. The bottom two are the raw, unpolished contig. These differ very slightly. </p> <p>To find breakpoints, we can look at points on the x-axis where there are unexpected changes.</p> <ol> <li>GC content should be roughly constant across a prokaryotic genome</li> <li>GC skew often has a single peak and a trough (see here)</li> <li>Coverage should be constant across a contig. However, DP1 (green) and DP2 (yellow) can vary significantly -- inexact repeat regions (across strains or species) can elevate the DP1/DP2 values.</li> <li>Read overlaps should be long. Small overlaps can be suspicious. High # of SNP differences are not ideal, but sometimes can not be avoided. </li> </ol>"},{"location":"qc_manual/#case-study-the-above-graph","title":"Case study: the above graph","text":"<p>The above graph is for a 99% complete but 18% contaminated contig from an anaerobic digester metagenome. We see irregularities at around the 2.6 Mbp position.</p> <p></p> <p>A few issues occur:</p> <ol> <li>The GC content has a noticeable downward shift</li> <li>The cumulative GC skew goes up and down again</li> <li>The DP1/DP2 coverages are variable and high, whereas DP1/DP2 before the breakpoint are consistently low</li> </ol> <p>This is quite strong evidence for a chimeric join. After removing the bases from 2.6 Mbp onward and rerunning CheckM2, we get a 97% complete and 0% contaminated contig, confirming our suspicion. </p> <p>Note</p> <p>Around the breakpoint, all overlaps have length &gt; 8kbp and are almost perfect. This was probably a recent horizontally transferred region. Even with long reads, metagenomic assembly is still extremely difficult. </p>"},{"location":"qc_statistics/","title":"QC Statistics","text":""},{"location":"qc_statistics/#using-checkm2-on-long-prokaryotic-contigs","title":"Using CheckM2 on long prokaryotic contigs","text":"<p>The easiest way to filter out long (&gt;300 kb) erroneous prokaryotic contigs is to run CheckM2 on individual contigs. </p> <p>If a chimeric contig is long enough, it will often have high CheckM contamination due to the presence of duplicated marker genes from multiple organisms. </p> <p>To extract all contigs of length &gt;= X bp and run CheckM2, you can do (with mylotools)</p> <pre><code>cd myloasm_results\nmylotools extract-contigs --output-folder contigs_dir --min-contig-length X\ncheckm2 predict --input contigs_dir -x fa -o checkm2_results --threads 40\n</code></pre>"},{"location":"qc_statistics/#using-k-mer-multiplicity-statistics-for-duplicatesstrain-chimeras","title":"Using k-mer multiplicity statistics for duplicates/strain chimeras","text":"<p>Myloasm's fasta outputs have information about how often 21-mers are repeated (its multiplicity) within a contig: </p> <p>&gt;u123123ctg_XXX_duplicated-yes mult=2.00 &lt;- fasta record with k-mer multiplicity and duplication status.</p> <p>In our experience, prokaryotic contigs should almost always have average k-mer multiplicity near 1.00. If you have a very long contig (&gt; 1M bp) of multiplicity &gt; 1.05, it may be a chimera from multiple strains of a species. We set <code>duplicated</code> to <code>yes</code> or <code>possibly</code> then the multiplicity is high. </p> <p>For small genomes (e.g. viruses), the expected k-mer multiplicity may deviate from 1.00. However, a small contig with k-mer multiplicity &gt;&gt; 1 can be suspicious. A contig with k-mer multiplicity = 2, 3, or an integer multiple can indicate a perfectly duplicated contig. </p>"},{"location":"qc_statistics/#notes-on-circularized-contigs","title":"Notes on circularized contigs","text":"<p>For prokaryotic genomes, low CheckM2 completeness can indicate premature circularization. However: </p> <ul> <li>we have found that complete organelle genomes (mitochondria, plastids from microeukaryotes) can have non-trivial CheckM2 completeness (&gt; 30% but &lt; 90%) </li> <li>secondary chromosomes and genomes with multiple chromosomes can have lower completeness</li> <li>some clades of microbes have low CheckM2 completeness scores, even when they're complete</li> </ul> <p>The myloasm tag <code>circular-possibly</code> indicates lower confidence circular genomes (due to low coverage or assembly graph ambiguity), but these can often be complete genomes, especially if CheckM2 scores are good. </p>"},{"location":"results/","title":"Preliminary Results","text":""},{"location":"results/#algorithm-outline","title":"Algorithm outline","text":"<p>At a high level, myloasm uses a string graph approach. Briefly, myloasm:</p> <ol> <li>aligns reads-to-reads, splits chimeric reads, and estimates coverage per read</li> <li>uses polymorphic, strain-specific k-mers (we call them SNPmers) to find true sequence divergence between reads </li> <li>obtains a high-resolution overlap graph and finds walks (contigs) with consistent coverage using an annealing-inspired optimization approach</li> <li>aligns reads-to-contigs and polishes using partial order alignment (SPOA)</li> </ol>"},{"location":"results/#results","title":"Results","text":"<p>Important</p> <p>The below results are slightly outdated. See the preprint for more details.</p> <p></p> Fig. 1. Metagenome-assembled genome (MAG) recovery for Nanopore R10.4 simplex + PacBio HiFi sequencing datasets. Alignment + binning was done with minimap2 and SemiBin2; results are evaulated with CheckM2.   <p></p> Fig. 2. Completeness + contamination results from CheckM2 on individual contigs for the different assemblers. Dashed line indicates circular complete MAGs (&gt; 90% complete, &lt; 5% contaminated and circular)."},{"location":"results/#dataset-accessions","title":"Dataset accessions","text":"Dataset (ONT R10.4) Accession Dataset (HiFi) Accession Oral 1  (Kiguchi et al.) DRR582205 Hot Spring  (Kato et al.) DRR290133 Oral 2    (Kiguchi et al.) DRR582179 Anaerobic Digester (Benoit et al.) ERR10905741 Gut 1   (Minich et al.) SRR29980972 Chicken Gut    (Zhang et al.) SRR19683891 Gut 2 (Minich et al.) SRR29980959 Human Gut (Gehrig et al.) SRR15489018 Gut 3    (Minich et al.) SRR29980980 P. Seawater  (Priest et al.) ERR4920901 S. Seawater (Sidhu et al.) ERR9769281"},{"location":"secondary/","title":"Secondary files","text":"<pre><code>\u251c\u2500\u2500 myloasm_(DATE + TIME).log\n\u251c\u2500\u2500 assembly_graphs/\n\u2502   \u251c\u2500\u2500 unitig_graph-0.gfa\n\u2502   \u251c\u2500\u2500 after_light_cleaning-1.gfa\n\u2502   \u251c\u2500\u2500 after_walk_heavy_cleaned-2.gfa\n\u2502   \u2514\u2500\u2500 small_and_tip_bubble-3.gfa\n\u251c\u2500\u2500 0-cleaning_and_unitigs/\n\u2502   \u2514\u2500\u2500 Read cleaning + mapping files\n\u251c\u2500\u2500 1-light_resolve/\n\u2502   \u2514\u2500\u2500 Initial graph cleaning files\n\u251c\u2500\u2500 2-heavy_path_resolve/\n\u2502   \u2514\u2500\u2500 Heavy graph cleaning files\n\u251c\u2500\u2500 3-mapping/\n\u2502   \u2514\u2500\u2500 map_to_unitigs.paf.gz\n\u251c\u2500\u2500 binary_temp/\n\u2502   \u2514\u2500\u2500 Large binary files \n\u2514\u2500\u2500 alternate_assemblies/\n    \u251c\u2500\u2500 duplicated_contigs.fa\n    \u2514\u2500\u2500 assembly_alternate.fa\n</code></pre>"},{"location":"secondary/#myloasm_log","title":"<code>myloasm_*.log</code>","text":"<p>Logging information. Has some extra information over just the stderr output. </p>"},{"location":"secondary/#assembly_graphs","title":"<code>assembly_graphs/</code>","text":"<p>Contains intermediate assembly graphs in GFA format. See here for more info about myloasm's GFA outputs.. </p> <ul> <li><code>unitig_graph-0.gfa</code> - raw unitigs with minimal cleaning. Usually extremely messy. </li> <li><code>after_light_cleaning-1.gfa</code> - lightly cleaned unitigs after removing relatively small overlaps</li> <li><code>after_walk_heavy_cleaned-2.gfa</code> - heavily cleaned unitigs after using coverage information.</li> <li><code>small_and_tip_bubble-3.gfa</code> - further cleaning of tips and rescuing some small circular contigs</li> </ul>"},{"location":"secondary/#0-cleaning_and_unitigs","title":"<code>0-cleaning_and_unitigs/</code>","text":"<p>These are files during the initial read-to-read mapping, read containment, and graph construction steps. </p> <ul> <li><code>all-cont.txt.gz</code> - containment status of all reads</li> <li><code>overlaps.txt.gz</code> - information about overlaps between non-contained reads</li> <li><code>read_coverages.txt.gz</code> - this file gives information about reads that are chimeric and where they get split</li> <li><code>remap_temp/</code> - we do multiple rounds of splitting and overlapping; these files are for the second round. </li> </ul>"},{"location":"secondary/#1-light_resolve","title":"<code>1-light_resolve/</code>","text":"<p>These files show intermediate assembly graphs during the initial, light graph cleaning iterations. </p>"},{"location":"secondary/#2-heavy_path_resolve","title":"<code>2-heavy_path_resolve/</code>","text":"<p>These files show intermediate assembly graphs and information about the inferred edge weights during the heavier graph cleaning iterations. </p> <p>The graphs look like: <code>heavy-m15-t0.5-r0.5.gfa</code>. Here, larger <code>m</code> indicates larger topological graph simplifications. <code>t</code> is the temperature (lower is more aggressive). <code>r</code> is the edge weight cut ratio (higher is more aggressive). </p>"},{"location":"secondary/#3-mapping","title":"<code>3-mapping/</code>","text":"<p>These files show how read (or contigs) map to the final unpolished contigs. We use \"unitigs\" and \"contigs\" interchangeably here. </p> <ul> <li><code>map_to_unitigs.paf.gz</code> - mapping of reads to unpolished unitigs in PAF format. There are additional columns indicating some SNP information. </li> <li><code>dereplicate_unitigs.paf.gz</code> - we map intermediate unitigs to other unitigs and filter out unitigs that map perfectly, prior to polishing. </li> </ul>"},{"location":"secondary/#binary_temp","title":"<code>binary_temp/</code>","text":"<p>These are large binary files that are dumped by myloasm. This is useful for rerunning myloasm after a failure by doing <code>myloasm -o output_dir exist</code> -- note the magic keyword <code>exist</code>. </p> <p>If you don't want these files to be output, use the <code>--clean-dir</code>. </p>"},{"location":"secondary/#alternate_assemblies","title":"<code>alternate_assemblies/</code>","text":"<ul> <li> <p>If a contig is &gt; 99.9% similar and contained in another contig, it is put into <code>duplicated_contigs.fa</code>. </p> </li> <li> <p>If a contig is &gt; 99% similar but &lt; 99.9% similar and contained in other contigs, we put it into <code>assembly_alternate.fa</code>. </p> </li> </ul>"},{"location":"usage/","title":"Quick usage","text":""},{"location":"usage/#nanopore-r104-suphac-basecalling","title":"Nanopore R10.4 (sup/hac basecalling)","text":"<pre><code>myloasm reads1.fq reads2.fq reads3.fq -o output_directory -t 50\n</code></pre> <ul> <li>Positional inputs are reads. Multiple reads are concatenated. Myloasm uses base qualities, so fastq files are preferred over fasta.</li> <li><code>-o</code>: results directory; a new directory is made if not present.</li> <li><code>-t</code>: number of threads</li> </ul>"},{"location":"usage/#pacbio-hifi","title":"PacBio HiFi","text":"<pre><code>myloasm reads1.fq reads2.fq reads3.fq -o output_directory -t 50 --hifi\n</code></pre> <ul> <li><code>--hifi</code>: append the HiFi flag is using HiFi reads. Everything else is the same. </li> </ul>"},{"location":"usage/#useful-common-parameters","title":"Useful common parameters","text":"<ul> <li><code>--clean-dir</code> - myloasm dumps large intermediate files to the results directory by default to enable rerunning from intermediate failure. Specify this flag to not dump these large files. </li> <li><code>--min-reads-contig</code> - myloasm outputs all contigs, even those with a single read, by default. Increase to retain only contigs with &gt;= X reads. </li> <li><code>-c</code> - increase this to reduce memory and increase speed with some sensitivity loss. Should be &lt;= 15.</li> <li><code>--quality-value-cutoff</code> - myloasm retains reads with only &gt;= X estimated accuracy for graph building. Increasing may create more accurate assembly graphs at a loss of sensitivity. </li> <li><code>--min-ol</code> - Allow overlaps of length &gt;= X for assembly graph construction. The default is quite aggressive and more sensitive at low coverage, but may lead to more false positives. Consider increasing for more accuracy for high coverage contigs. </li> <li><code>--bloom-filter-size</code> - The Bloom filter size in GB. Myloasm uses a bloom filter for reducing memory during the k-mer counting stage. Consider increasing for large metagenomes (&gt; 100 Gbp)</li> <li><code>--aggressive-bloom</code> - Use a more aggressive Bloom filtering strategy. Makes results non-deterministic, but saves some memory during initial k-mer counting step.</li> </ul>"}]}